// Copyright (c) 2021 - Rodolfo Calzetti
// Hooman v2 Parser
// MIT License 
'use strict';
class HoomanCompound {version = 1;objectType = "HoomanCompound";constructor() {this.limb = new HoomanLimb("_ROOT", null);this.classifier = "";this.inclusions = [];this.isDynamic = false;this.isSyntactic = false;this.hasWildcard = false;this.syntaxMain = false;this.syntaxIncluded = false;}get complexValue () {return this.limb.complexValue;}get name () {return this.limb.name;}getSimpleValue () {return "";}getActualValue () {return "";}getValueType () {return HoomanStatics.typeComplex;}prune () {this.limb.prune();}count () {this.limb.count();}pathValue (pathName, defaultValue = "") {try {let pathArray = pathName.split("/");let l = this.limb.complexValue;let i;for (i = 0; i <= pathArray.length - 2; i++) {l = l.getLimb( pathArray[i] ).complexValue;}return l.getLimb( pathArray[i] ).simpleValue;}catch (ex) {return defaultValue;}}pathExists (pathName) {try {let pathArray = pathName.split("/");let l = this.limb.complexValue;let i;let e = true;for (i = 0; i <= pathArray.length - 2; i++) {if (l.exists(pathArray[i])) {l = l.getLimb( pathArray[i] ).complexValue;}else {e = false;break;}}if (e && !l.exists(pathArray[i])) {e = false;}return e;}catch (ex) {return false;}}get root () {return this.limb;}getLimb (name) {return this.limb.complexValue.getLimb(name);}getValue (name, defaultValue = null) {if (defaultValue !== null) {return this.limb.complexValue.getValue(name);}else {return this.limb.complexValue.getValue(name, defaultValue);}}get lastLimb () {if (this.limb.complexValue.count() > 0) {return this.limb.complexValue.last;}else {return new HoomanLimb("0", this.limb);}}get tag () {return this.limb.tag;}set tag (value) {this.limb.tag = value;}get row () {return 0;}get level () {return -1;}get docRef () {return 1;}get owner () {return 0;}get parent () {return null;}get isWildcard () {return false;}buildPath () {return "";}}class HoomanDocument {_indentation;constructor (parser, name, offset) {this.parser = parser;this.name = name;this.spacesForTab = 4;this.offset = offset;this._indentation = 0;this.row = 1;this.newLine = false;this.newLineCharacter = "\n";this.isSpacesForTabSettled = false;this.isNewLineCharacterSettled = false;this.guillemotBuffer = [];this.guillemotSession = false;this.guillemotSkipNewLine = false;this.notInitialized = true;this.countSpaces = -1;this.docRef = 0;this.locked = false;}get namex () {if (this.name != "") {return "[ " + this.name + " ] ";}else {return "";}}get indentation () {return this.offset + this._indentation;}set indentation (value) {if (value > this._indentation + 1) {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 1;let message = "{0}Wrong indentation at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}this._indentation = value;}inputManagement (currChar) {if (this.notInitialized) {if (!this.isNewLineCharacterSettled) {if (currChar == "\n") {this.newLineCharacter = "\n";this.isNewLineCharacterSettled = true;}else if (currChar == "\r") {this.newLineCharacter = "\r";this.isNewLineCharacterSettled = true;}}if (!this.isSpacesForTabSettled) {if (currChar == this.newLineCharacter) {this.countSpaces = 0;}else if (currChar == " " && this.countSpaces >= 0) {this.countSpaces++;}else if (currChar == "\t") {this.spacesForTab = 4;this.isSpacesForTabSettled = true;}else {if (this.countSpaces > 0) {this.spacesForTab = this.countSpaces;this.isSpacesForTabSettled = true;}this.countSpaces = -1;}}if (this.isNewLineCharacterSettled && this.isSpacesForTabSettled) {this.notInitialized = false;}}if (currChar == this.newLineCharacter) {this.newLine = true;}if ((currChar == "\r" && this.newLineCharacter != "\r") || (currChar == "\n" && this.newLineCharacter != "\n")) {return false;}else {return true;}}}class HoomanDocumentInfo {name;tagName;locked;constructor(name) {this.name = name;if (name == "") {this.tagName = "";}else {this.tagName = "[ " + name + " ] ";}this.locked = false;}}class HoomanEmbodimentFile {baseDir;constructor(baseDir = "") {if (baseDir != "" && !baseDir.endsWith("/")) {baseDir += "/";}this.baseDir = baseDir;}getContents (coords) {if (coords.indexOf("//") == -1 && coords.indexOf(":") == -1) {coords = this.baseDir + coords;}let prom = new Promise(function(resolve, reject) {try {var fs = require('fs');var data = fs.readFileSync(coords, { encoding: "utf8" });if (!data.endsWith("\n") && !data.endsWith("\r")) {if (data.indexOf("\r\n")) {data += "\r\n";}else if (data.indexOf("\r")) {data += "\r";}else {data += "\n";}}resolve(data);}catch (ex) {reject({message: ex.message});}});return prom;}}class HoomanEngineJS {_codebase;constructor (codebase) {this._codebase = codebase + "\n";}execute (code){this._codebase += code + ";\n";}invoke (formula) {return eval(this._codebase + formula + "();");}}class HoomanExport2JSON {_root;_detectArray;constructor(limb, detectArray = true) {this._root = limb;this._detectArray = detectArray;}export () {try {var build = [];this._recursiveWalk(build, this._root, 0);return build.join("");}catch (ex) {throw new Error(ex.message);}}_recursiveWalk(build, limb, level) {let isArray = false;if (this._detectArray) {let progr = 1;isArray = true;for (let l of limb.complexValue) {if (l.name != progr) {isArray = false;break;}progr++;}}var flagComma = false;if (isArray) {build.push("[");}else {build.push("{");}for (let l of limb.complexValue) {if (level > 1 || l.name.toLowerCase() != "hooman") {if (flagComma) {build.push(",");}if (!isArray) {build.push("\"");if (/^\d/.test(l.name)) {build.push("i");}build.push(l.name.toLowerCase());build.push("\"");build.push(":");}if (l.valueType == HoomanStatics.typeSimple) {let oVl = l.actualValue;let sVl;let flagQuote = true;if (oVl.constructor.name == "String") {sVl = oVl .replace(/\\/g, "\\\\") .replace(/\r/g, "\\r") .replace(/\n/g, "\\n") .replace(/\t/g, "\\t") .replace(/\"/g, "\\\"");}else if (oVl.constructor.name == "Date") {sVl =  (oVl.getFullYear() + "-" +("0"+(oVl.getMonth()+1)).slice(-2) + "-" +("0" + oVl.getDate()).slice(-2) + "T" +("0" + oVl.getHours()).slice(-2) + ":" +("0" + oVl.getMinutes()).slice(-2) + ":" +("0" + oVl.getSeconds()).slice(-2)) .replace("T00:00:00", "");}else {sVl = oVl.toString();flagQuote = false;}if (flagQuote) {build.push("\"");}build.push(sVl);if (flagQuote) {build.push("\"");}}else {this._recursiveWalk(build, l, level + 1);}flagComma = true;}}if (isArray) {build.push("]");}else {build.push("}");}}}class HoomanExportStructure2JSON {_root;constructor(limb) {this._root = limb.getLimb("hooman").getLimb("syntax").getLimb("structure");}export () {try {var build = [];build.push("{");this._recursiveWalk(build, this._root, 1);build.push("}");return build.join("");}catch (ex) {throw new Error(ex.Message);}}_recursiveWalk(build, limb, level) {build.push("\"_nodeInfo\":{");build.push("\"iswildcard\":");build.push((limb.isWildcard ? "1" : "0"));build.push(",");build.push("\"haswildcard\":");build.push((limb.hasWildcard ? "1" : "0"));build.push(",");build.push("\"isrecursive\":");build.push((limb.isRecursive ? "1" : "0"));build.push("}");for (let l of limb.complexValue) {build.push(",");build.push("\"");if (/^\d/.test(l.name)) {build.push("i");}build.push(l.name.toLowerCase());build.push("\"");build.push(":");if (l.valueType == HoomanStatics.typeSimple) {let oVl = l.actualValue;let sVl;let flagQuote = true;if (oVl.constructor.name == "String") {sVl = oVl .replace(/\\/g, "\\\\") .replace(/\r/g, "\\r") .replace(/\n/g, "\\n") .replace(/\t/g, "\\t") .replace(/\"/g, "\\\"");}else if (oVl.constructor.name == "Date") {sVl =  (oVl.getFullYear() + "-" +("0"+(oVl.getMonth()+1)).slice(-2) + "-" +("0" + oVl.getDate()).slice(-2) + "T" +("0" + oVl.getHours()).slice(-2) + ":" +("0" + oVl.getMinutes()).slice(-2) + ":" +("0" + oVl.getSeconds()).slice(-2)) .replace("T00:00:00", "");}else {sVl = oVl.toString();flagQuote = false;}if (flagQuote) {build.push("\"");}build.push(sVl);if (flagQuote) {build.push("\"");}}else {build.push("{");this._recursiveWalk(build, l, level + 1);build.push("}");}}}}class HoomanLimb {name;tag;valueType;_simpleValue;_actualValue;_complexValue;row;level;docRef;owner;parent;isWildcard;hasWildcard;isRecursive;objectType = "HoomanLimb";constructor(name, parent, value = "", docRef = -1, row =-1) {this.name = name;this.parent = parent;this.tag = "";if (docRef >= 0) {this.valueType = HoomanStatics.typeSimple;}else {this.valueType = HoomanStatics.typeComplex;}this._simpleValue = value;this._actualValue = value;this._complexValue = new HoomanLimbs(this);this.docRef = docRef;this.owner = docRef;this.row = row;if (parent) {this.level = parent.level + 1;}else {this.level = 0;}this.isWildcard = false;this.hasWildcard = false;this.isRecursive = false;}prune () {this.valueType = HoomanStatics.typeComplex;this._simpleValue = "";this._actualValue= "";this._complexValue.clear();}count () {return this._complexValue.count();}get simpleValue () {if (this.valueType == HoomanStatics.typeSimple) {return this._simpleValue;}else {throw new Error("Field [ {0} ] has complex value".format(this.name));}}set simpleValue (value) {if (this.valueType == HoomanStatics.typeSimple) {this._simpleValue = value;this._actualValue = value;}}get actualValue () {if (this.valueType == HoomanStatics.typeSimple) {return this._actualValue;}else {throw new Error("Coding error ref. [00002]");}}set actualValue (value) {this._actualValue = value;}get complexValue () {if (this.valueType == HoomanStatics.typeComplex) {return this._complexValue;}else {throw new Error("Coding error ref. [00003]");}}getLimb (name) {return this._complexValue.getLimb(name);}getValue (name, defaultValue = null) {if (defaultValue === null) {return this._complexValue.getValue(name);}else {return this._complexValue.getValue(name, defaultValue);}}get lastLimb () {if (this._complexValue.count() > 0) {return this._complexValue.last;}else {return new HoomanLimb("0", this);}}buildPath () {try {var maxPath = 0;var p = [];p[maxPath] = this.name;var l = this;while (l.parent != null) {let name = l.parent.name;if (name != "_ROOT") {maxPath++;p[maxPath] = name;}l = l.parent;}p = p.reverse();return p.join("/");}catch (ex) {throw new Error(ex.message);}}}class HoomanLimbs {_collItem = new Map();_collIndex = [];parent;nextIndex;constructor(parent) {this.parent = parent;this.nextIndex = 0;}getValue (name, defaultValue = null) {name = name.toLowerCase();if (defaultValue !== null) {if (this._collItem.has(name)) {return this._collItem.get(name).simpleValue;}else {return defaultValue;}}else {if (this._collItem.has(name)) {return this._collItem.get(name).complexValue;}else{return new HoomanLimbs(this.parent);}}}getLimb (name) {name = name.toLowerCase();if (this._collItem.has(name)) {return this._collItem.get(name);}else {return new HoomanLimb(name, this.parent);}}setLimb (limb) {if (limb.valueType == HoomanStatics.typeSimple) {var name = limb.name.toLowerCase();if (this._collItem.has(name)) {var prevItem = this._collItem.get(name);if (prevItem.valueType == HoomanStatics.typeSimple) {limb.owner = prevItem.owner;this._collItem.delete(name);if (limb.simpleValue == null) {limb.simpleValue = "";}this._collItem.set(name, limb);}else {limb = prevItem;}}else {if (limb.simpleValue === null) {limb.simpleValue = "";}this._collItem.set(name, limb);this._collIndex[this.nextIndex] = name;this.nextIndex++;}}else {throw new Error("Internal error");}return limb;}getLimbByIndex (index) {if (this._collIndex[index]) {return this._collItem.get( this._collIndex[index] );}else {throw new Error("Index out of range");}}count () {return this._collItem.size;}clear () {this._collItem.clear();this._collIndex = [];this.nextIndex = 0;}exists (name) {return this._collItem.has(name);}get last() {if (this.nextIndex > 0) {return this._collItem.get(this._collIndex[ this.nextIndex - 1 ]);}else {return null;}}[Symbol.iterator] = function * () {for (let pair of this._collItem) {yield pair[1];}}}class HoomanParser {_currentPhase;constructor(embodiment) {this.resolve = null;this.reject = null;this.currentState = null;this._currentPhase = null;this.stackDocuments = new HoomanStackDocuments(this);this.stackLimbs = new HoomanStackLimbs();this.stackInfos = new HoomanStackInfos(this);this.stackStreams = new HoomanStackStreams();this.compound = null;this.embodiment = embodiment;this.thenOccurred = false;this.structureInfo = null;this.rules = new HoomanRules(this);this.currentRule = null;this.stateAssignment = new HoomanStateAssignment(this);this.stateBOM = new HoomanStateBOM(this);this.stateFinal = new HoomanStateFinal(this);this.stateGuillemotBegin = new HoomanStateGuillemotBegin(this);this.stateGuillemotBody = new HoomanStateGuillemotBody(this);this.stateGuillemotEnd = new HoomanStateGuillemotEnd(this);this.stateGuillemotIndentation = new HoomanStateGuillemotIndentation(this);this.stateIncludeSub = new HoomanStateIncludeSub(this);this.stateIncludeText = new HoomanStateIncludeText(this);this.stateIndentation = new HoomanStateIndentation(this);this.stateInitial = new HoomanStateInitial(this);this.stateLessThan = new HoomanStateLessThan(this);this.statePlus = new HoomanStatePlus(this);this.stateRemark = new HoomanStateRemark(this);this.stateThen = new HoomanStateThen(this);this.stateValue = new HoomanStateValue(this);this.stateVariable = new HoomanStateVariable(this);this.stateAssignment.initialize();this.stateBOM.initialize();this.stateFinal.initialize();this.stateGuillemotBegin.initialize();this.stateGuillemotBody.initialize();this.stateGuillemotEnd.initialize();this.stateGuillemotIndentation.initialize();this.stateIncludeSub.initialize();this.stateIncludeText.initialize();this.stateIndentation.initialize();this.stateInitial.initialize();this.stateLessThan.initialize();this.statePlus.initialize();this.stateRemark.initialize();this.stateThen.initialize();this.stateValue.initialize();this.stateVariable.initialize();this.phaseBeginData = new HoomanPhaseBeginData(this);this.phaseData = new HoomanPhaseData(this);this.phaseHooman = new HoomanPhaseHooman(this);this.phaseLibrary = new HoomanPhaseLibrary(this);this.phaseModules = new HoomanPhaseModules(this);this.phaseRules = new HoomanPhaseRules(this);this.phaseStructure = new HoomanPhaseStructure(this);this.phaseSyntax = new HoomanPhaseSyntax(this);this.phaseUndefined = new HoomanPhaseUndefined(this);this.includedDocuments = [];this.modules = [];}get document () {return this.stackDocuments.top;}get currentPhase () {return this._currentPhase;}set currentPhase (value) {this._currentPhase = value;/* moscaif (this._currentPhase instanceof HoomanPhaseSyntax) {let syntaxLevel = this.compound.syntaxLevel;if (this.stackDocuments.topIndex > 1) {if (syntaxLevel == 0) {this.compound.syntaxLevel = 2;}else if (syntaxLevel == 1) {let doc = "";let line = 0;let code = 4;let message = "A syntactic section already exists in the main document";this.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}else if (syntaxLevel == 0) {this.compound.syntaxLevel = 1;}else if (syntaxLevel == 2) {let doc = "";let line = 0;let code = 5;let message = "A syntactic section already exists in an included document";this.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}*/if (this._currentPhase instanceof HoomanPhaseSyntax) {if (this.stackDocuments.topIndex > 1) {this.compound.syntaxIncluded = true;}else {this.compound.syntaxMain = true;}}}changeState (newState, nextChar) {this.currentState.complete();this.currentState = newState;this.currentState.reset();if (nextChar !== null) {this.currentState.nextSymbol(nextChar);}}startProcess(name, streamIn) {this.compound = new HoomanCompound();this.currentState = this.stateInitial;this.currentPhase = this.phaseUndefined;this.structureInfo = new HoomanStructureInfo(this, "_ROOT");this.includedDocuments = [];this.stackDocuments.reset();this.stackDocuments.push(new HoomanDocument(this, "", 0));this.stackLimbs.reset();this.stackLimbs.push(this.compound);this.stackInfos.reset();this.stackInfos.push(this.structureInfo);this.modules = [];this.currentRule = null;this.rules.clear();this.stackDocuments.push(new HoomanDocument(this, name, this.stackDocuments.top.indentation));this.stackStreams.reset();this.stackStreams.push(streamIn);this.streamProcess(streamIn);}streamProcess (streamIn) {try {do {let currChar = streamIn.getNext();if (currChar == "") {this.currentState.finalCheck();this.changeState(this.stateFinal, null);this.stackDocuments.pop();this.stackStreams.pop();if (this.stackStreams.topIndex >= 0) {if (this.document.guillemotSession) {this.currentState = this.stateGuillemotIndentation;}else {this.currentState = this.stateIndentation;}this.streamProcess (this.stackStreams.top);}else {this.currentPhase = this.phaseBeginData;this.currentPhase.stackManagement(null);this.rules.syntaxCheck();for (var m of this.modules) {if (this.compound.inclusions.indexOf(m) == -1) {let doc = "";let line = 0;let code = 6;let message = "Module [ {0} ] is required".format(m);this.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}this.resolve(this.compound);}break;}let top = this.stackDocuments.top;if (top.inputManagement(currChar)) {if (this.currentState.nextSymbol(currChar)) {break;}}if (top.newLine) {top.row++;top.newLine = false;}} while (true);}catch (ex) {let doc = "";let line = 0;let code = 26;this.reject({message: ex.message, document: doc, line: line, code: code});}}stackManagement (name) {let l = this.currentPhase.bodyBuilder(name);this.currentPhase.stackManagement(l);}}class HoomanPhase {docIndentation;docRef;docRow;constructor(parser) {this.parser = parser;this.stackDocuments = parser.stackDocuments;this.stackLimbs = parser.stackLimbs;this.rules = parser.rules;}bodyBuilder(name){let t = this.stackDocuments.top;this.docIndentation = t.indentation;this.docRef = t.docRef;this.docRow = t.row;if (this.docIndentation < this.stackLimbs.topIndex) {do {this.stackLimbs.pop();} while (this.docIndentation != this.stackLimbs.topIndex);}if (name == "+") {let lastLimbName = this.stackLimbs.top.lastLimb.name;if (/^\d+$/.test(lastLimbName)) {name = (parseInt(lastLimbName) + 1).toString();}else {let doc = this.stackDocuments.top.namex;let line = this.stackDocuments.top.row;let code = 7;let message = "{0}Plus operator cannot be resolved at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}var l;if (this.stackLimbs.top.objectType == "HoomanLimb") {var lParent = this.stackLimbs.top;l = new HoomanLimb(name, lParent, "", this.docRef, this.docRow);if (lParent.objectType == "HoomanLimb") {lParent.valueType = HoomanStatics.typeComplex;}l = lParent.complexValue.setLimb(l);}else {let cParent = this.stackLimbs.top;l = new HoomanLimb(name, cParent, "", this.docRef, this.docRow);l = cParent.complexValue.setLimb(l);}this.stackLimbs.push(l);return l;}stackManagement(limb) {return false;}valueManagement(value) {}}class HoomanPhaseBeginData extends HoomanPhase {constructor(parser) {super(parser);}stackManagement (limb) {this.parser.stackInfos.reset();this.parser.stackInfos.push(this.parser.structureInfo);this.rules.hasSyntaxStructure = (this.parser.structureInfo.infos.count() > 0);this.rules.hasSyntaxRules = (this.parser.rules.count() > 0);if (this.parser.compound.version < 2) {}this.parser.currentPhase = this.parser.phaseData;if (limb !== null) {let t = this.stackDocuments.top;this.parser.currentPhase.docRef = t.docRef;this.parser.currentPhase.docRow = t.row;this.parser.currentPhase.stackManagement(limb);}return false;}}class HoomanPhaseData extends HoomanPhase {constructor(parser) {super(parser);}stackManagement (limb) {if (this.parser.compound.isSyntactic) {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 28;let message = "{0}Syntactic document should not contain any data at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}if (this.docIndentation == 0) {if (limb.name.toLowerCase() == "hooman") {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 8;let message = "{0}The hooman branch cannot be changed after data entry at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}if (this.parser.compound.syntaxMain && this.parser.compound.syntaxIncluded) {let doc = "";let line = 0;let code = 5;let message = "A syntactic section already exists in an included document";this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}if (this.rules.hasSyntaxStructure) {var s;if (this.docIndentation < this.parser.stackInfos.topIndex) {do {this.parser.stackInfos.pop();} while (this.docIndentation != this.parser.stackInfos.topIndex);}if (this.parser.stackInfos.top.hasWildcard) {s = this.parser.stackInfos.top.infos.first;}else {s = this.parser.stackInfos.top.infos.getInfo(limb.name);}if (s.hasDefault) {for (let f of s.infos) {if (f.isDefault) {if (limb.objectType == "HoomanLimb") {limb.valueType = HoomanStatics.typeComplex;}limb.complexValue.setLimb(new HoomanLimb(f.name, limb, f.defaultValue, this.docRef, this.docRow));}}}if (s.infos.count() > 0) {if (limb.valueType == HoomanStatics.typeSimple) {limb.valueType = HoomanStatics.typeComplex;}}this.parser.stackInfos.push(s);}return false;}}class HoomanPhaseHooman extends HoomanPhase {constructor(parser) {super(parser);}stackManagement (limb) {switch (this.docIndentation) {case 0:if (limb.name.toLowerCase() != "hooman") {this.parser.currentPhase = this.parser.phaseBeginData;this.parser.currentPhase.stackManagement(limb);}break;case 1:switch (limb.name.toLowerCase()) {case "syntax":this.parser.currentPhase = this.parser.phaseSyntax;break;case "locked":this.stackDocuments.top.locked = true;this.parser.includedDocuments[this.stackDocuments.top.docRef].locked = true;}}return false;}valueManagement (value) {if (this.stackDocuments.top.indentation == 1) {switch (this.stackLimbs.top.name.toLowerCase()) {case "version":if (/^\d+$/.test(value)) {if (this.stackDocuments.topIndex == 1) {this.parser.compound.version = parseInt(value).toString();}}else {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 9;let message = "{0}Version must be an integer at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}break;case "classifier":if ((/^[A-Z_0-9]+$/i).test(value)) {if (this.stackDocuments.topIndex == 1) {this.parser.compound.classifier = value.toLowerCase();}else {this.parser.compound.inclusions.push(value.toLowerCase());}}else {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 10;let message = "{0}Invalid classifier at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}break;}}}}class HoomanPhaseLibrary extends HoomanPhase {constructor(parser) {super(parser);}stackManagement (limb) {var caseElse = false;switch (this.docIndentation) {case 0:switch (limb.name.toLowerCase()) {case "hooman":this.parser.currentPhase = this.parser.phaseHooman;break;default:this.parser.currentPhase = this.parser.phaseBeginData;this.parser.currentPhase.stackManagement(limb);}break;case 1:switch (limb.name.toLowerCase()) {case "syntax":this.parser.currentPhase = this.parser.phaseSyntax;break;default:this.parser.currentPhase = this.parser.phaseHooman;}break;case 2:switch (limb.name.toLowerCase()) {case "structure":this.parser.currentPhase = this.parser.phaseStructure;break;case "rules":this.parser.currentPhase = this.parser.phaseRules;break;case "modules":this.parser.currentPhase = this.parser.phaseModules;break;case "library":this.parser.currentPhase = this.parser.phaseLibrary;break;}break;default:if (this.docIndentation > 3) {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 11;let message = "{0}Wrong indentation at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}return false;}valueManagement (value) {if (this.stackLimbs.top.tag == "js") {this.rules.scriptJS.push(value);this.rules.scriptJS.push("\n");}}}class HoomanPhaseModules extends HoomanPhase {constructor(parser) {super(parser);}stackManagement (limb) {var caseElse = false;switch (this.docIndentation) {case 0:switch (limb.name.toLowerCase()) {case "hooman":this.parser.currentPhase = this.parser.phaseHooman;break;default:this.parser.currentPhase = this.parser.phaseBeginData;this.parser.currentPhase.stackManagement(limb);}break;case 1:switch (limb.name.toLowerCase()) {case "syntax":this.parser.currentPhase = this.parser.phaseSyntax;break;default:this.parser.currentPhase = this.parser.phaseHooman;}break;case 2:switch (limb.name.toLowerCase()) {case "structure":this.parser.currentPhase = this.parser.phaseStructure;break;case "rules":this.parser.currentPhase = this.parser.phaseRules;break;case "modules":this.parser.currentPhase = this.parser.phaseModules;break;case "library":this.parser.currentPhase = this.parser.phaseLibrary;break;}break;default:if (this.docIndentation == 3) {this.parser.modules.push(limb.name.toLowerCase());}else {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 12;let message = "{0}Wrong indentation at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}return false;}}class HoomanPhaseRules extends HoomanPhase {constructor(parser) {super(parser);}stackManagement (limb) {var caseElse = false;switch (this.docIndentation) {case 0:switch (limb.name.toLowerCase()) {case "hooman":this.parser.currentPhase = this.parser.phaseHooman;break;default:this.parser.currentPhase = this.parser.phaseBeginData;this.parser.currentPhase.stackManagement(limb);}break;case 1:switch (limb.name.toLowerCase()) {case "syntax":this.parser.currentPhase = this.parser.phaseSyntax;break;default:this.parser.currentPhase = this.parser.phaseHooman;}break;case 2:switch (limb.name.toLowerCase()) {case "structure":this.parser.currentPhase = this.parser.phaseStructure;break;case "rules":this.parser.currentPhase = this.parser.phaseRules;break;case "modules":this.parser.currentPhase = this.parser.phaseModules;break;case "library":this.parser.currentPhase = this.parser.phaseLibrary;break;}break;default:if (this.docIndentation == 3) {this.parser.thenOccurred = false;this.parser.currentRule = new HoomanRule(limb.name);this.parser.rules.add(this.parser.currentRule);}else if (this.docIndentation > 4) {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 13;let message = "{0}Wrong indentation at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}return false;}valueManagement (value) {if (this.stackDocuments.top.indentation >= 4) {if (this.parser.thenOccurred) {var objTop = this.stackLimbs.top;if (objTop.tag == "js") {this.rules.functProgr++;let functName = "__" + objTop.name + "_" + this.rules.functProgr;this.rules.scriptJS.push("function ");this.rules.scriptJS.push(functName);this.rules.scriptJS.push("(){");this.rules.scriptJS.push("\n");this.rules.scriptJS.push("    return ");this.rules.scriptJS.push(value);this.rules.scriptJS.push(";");this.rules.scriptJS.push("\n");this.rules.scriptJS.push("}");this.rules.scriptJS.push("\n");value = functName;}this.parser.currentRule.addClause(new HoomanRuleClause(objTop.name, value, objTop.tag.toLowerCase()));}else {this.parser.currentRule.addContext(new HoomanRuleContext(this.stackLimbs.top.name, value));}}}}class HoomanPhaseStructure extends HoomanPhase {constructor(parser) {super(parser);}stackManagement (limb) {switch (this.docIndentation) {case 0:switch (limb.name.toLowerCase()) {case "hooman":this.parser.currentPhase = this.parser.phaseHooman;break;default:this.parser.currentPhase = this.parser.phaseBeginData;this.parser.currentPhase.stackManagement(limb);}break;case 1:switch (limb.name.toLowerCase()) {case "syntax":this.parser.currentPhase = this.parser.phaseSyntax;break;default:this.parser.currentPhase = this.parser.phaseHooman;}break;case 2:switch (limb.name.toLowerCase()) {case "structure":this.parser.currentPhase = this.parser.phaseStructure;break;case "rules":this.parser.currentPhase = this.parser.phaseRules;break;case "modules":this.parser.currentPhase = this.parser.phaseModules;break;case "library":this.parser.currentPhase = this.parser.phaseLibrary;break;}break;default:if (this.docIndentation - 3 < this.parser.stackInfos.topIndex) {do {this.parser.stackInfos.pop();} while (this.docIndentation - 3 != this.parser.stackInfos.topIndex);}if (this.parser.stackInfos.top.hasWildcard) {let doc = this.stackDocuments.top.namex;let line = this.stackDocuments.top.row;let code = 14;let message = "{0}A wildcard variable cannot have siblings at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}if (this.parser.stackInfos.top.infos.exists(limb.name)) {this.parser.stackInfos.push(this.parser.stackInfos.top.infos.getInfo(limb.name));}else {let s = new HoomanStructureInfo(this.parser, limb.name);this.parser.stackInfos.top.infos.add(s);this.parser.stackInfos.push(s);}}return false;}valueManagement (value) {this.parser.stackInfos.valueManagement(value);if (this.parser.stackInfos.top.isWildcard) {this.parser.stackLimbs.top.isWildcard = true;}if (this.parser.stackInfos.topParent.hasWildcard) {this.parser.stackLimbs.top.parent.hasWildcard = true;}if (this.parser.stackInfos.top.isRecursive) {this.parser.stackLimbs.top.isRecursive = true;}}}class HoomanPhaseSyntax extends HoomanPhase {constructor(parser) {super(parser);}stackManagement (limb) {switch (this.docIndentation) {case 0:switch (limb.name.toLowerCase()) {case "hooman":this.parser.currentPhase = this.parser.phaseHooman;break;default:this.parser.currentPhase = this.parser.phaseBeginData;this.parser.currentPhase.stackManagement(limb);}break;case 1:switch (limb.name.toLowerCase) {case "syntax":this.parser.currentPhase = this.parser.phaseSyntax;break;default:this.parser.currentPhase = this.parser.phaseHooman;}break;case 2:switch (limb.name.toLowerCase()) {case "structure":this.parser.currentPhase = this.parser.phaseStructure;break;case "rules":this.parser.currentPhase = this.parser.phaseRules;break;case "modules":this.parser.currentPhase = this.parser.phaseModules;break;case "library":this.parser.currentPhase = this.parser.phaseLibrary;break;}}return false;}valueManagement (value) {switch (this.stackLimbs.top.name.toLowerCase()) {case "syntax":if (value == "!") {if (this.stackDocuments.topIndex == 1) {this.parser.compound.isSyntactic = true;}}break;}}}class HoomanPhaseUndefined extends HoomanPhase {constructor(parser) {super(parser);}stackManagement (limb) {switch (limb.name.toLowerCase()) {case "hooman":this.parser.currentPhase = this.parser.phaseHooman;break;default:this.parser.currentPhase = this.parser.phaseBeginData;this.parser.currentPhase.stackManagement(limb);}return false;}}class HoomanRule {name;_collContext;_collClause;constructor (name) {this.name = name;this._collContext = new Set();this._collClause = new Set();}get contexts () {return this._collContext;}get clauses () {return this._collClause;}addContext (x) {this._collContext.add(x);}addClause (x) {this._collClause.add(x);}clear () {this._collContext.clear();this._collClause.clear();}}class HoomanRuleClause {name;pattern;tag;constructor (n, p, t) {this.name = n;this.pattern = p;this.tag = t;}}class HoomanRuleContext {name;pattern;constructor (n, p) {this.name = n;this.pattern = p;}}class HoomanRuleInfo {value;docRef;row;constructor (v, d, r) {this.value = v;this.docRef = d;this.row = r;}}class HoomanRules {_parser;scriptJS;functProgr;engineJS;hasSyntaxStructure;hasSyntaxRules;structureInfo;stackInfos;_collItem;_collFields;_collIndex;constructor(parser) {this._parser = parser;this.scriptJS = [];this.functProgr = 0;this.stackInfos = parser.stackInfos;this._collItem = new Map();this._collFields = new Map();this._collIndex = new Map();}count () {return this._collItem.size;}add (item) {var name = item.name.toLowerCase();this._collItem.set(name, item);}clear () {this._collItem.clear();this._collIndex.clear();this.hasSyntaxStructure = false;this.hasSyntaxRules = false;this.scriptJS = [];this.functProgr = 0;}addField (name, info) {this._collFields.set(name, info);}getRules (name) {if (this._collIndex.has(name.toLowerCase())) {return this._collIndex.get(name.toLowerCase());}else {return null;}}checkRules (checkType) {for (let k of this._collFields) {var limb = k[1];var id = limb.name.toLowerCase();var vl = limb.simpleValue;var dr = limb.docRef;var rw = limb.row;var rules = this.getRules(id);if (rules !== null) {for (let r of rules) {var ok = true;var condExists = (r.contexts.size == 0);var idRule = "";var vlRule = "";var tgRule = "";var regex;var matchRule;for (let context of r.contexts) {idRule = context.name.toLowerCase();vlRule = context.pattern;if (this._collFields.has(idRule)) {condExists = true;regex = new RegExp("^" + vlRule + "$", "i");matchRule = this._collFields.get(idRule).simpleValue.match(regex);if (matchRule == null) {ok = false;break;}}else {let doc = this._parser.includedDocuments[dr].tagName;let line = rw;let code = 15;let message = "{0}Simple variable [ {1} ] is mandatory because it is precondition in a rule at row {2}".format(doc, idRule, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}if (ok && condExists) {for (let clause of r.clauses) {idRule = clause.name.toLowerCase();vlRule = clause.pattern;tgRule = clause.tag.toLowerCase();if (idRule == id) {let checkDate = false;let checkNumber = false;let codeJS = false;if (tgRule.startsWith("date")) {checkDate = true;}else if (tgRule.startsWith("number")) {checkNumber = true;}else if (tgRule == "js") {codeJS = true;}if (checkType == 1 && codeJS) {this.assignLimb(limb, vlRule);}else if (checkType == 0 && !codeJS) {regex = new RegExp("^" + vlRule + "$", "i");matchRule = vl.match(regex);if (matchRule == null) {let doc = this._parser.includedDocuments[dr].tagName;let line = rw;let code = 16;let message = "{0}The [ {1} {2} ] assignment does not match the pattern at row {3}".format(doc, id, vl, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}else if (checkDate) {let ye = 0;let mo = 0;let da = 0;let ho = 0;let mi = 0;let se = 0;let dateTest;if ((matchRule.length - 1) >= 3) {switch (tgRule) {case "date[ymd]":case "date":ye = parseInt(matchRule[1]);mo = parseInt(matchRule[2]);da = parseInt(matchRule[3]);break;case "date[dmy]":ye = parseInt(matchRule[3]);mo = parseInt(matchRule[2]);da = parseInt(matchRule[1]);break;case "date[mdy]":ye = parseInt(matchRule[3]);mo = parseInt(matchRule[1]);da = parseInt(matchRule[2]);break;default:let doc = this._parser.includedDocuments[dr].tagName;let line = rw;let code = 17;let message = "{0}Unmanaged tag [ {1} ] at row {2}".format(doc, tgRule, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}else {let doc = this._parser.includedDocuments[dr].tagName;let line = rw;let code = 18;let message = "{0}Bad date pattern at row {1}: the groups must be 3, 5 or 6".format(doc, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}switch (matchRule.length - 1) {case 3:break;case 5:ho = parseInt(matchRule[4]);mi = parseInt(matchRule[5]);break;case 6:ho = parseInt(matchRule[4]);mi = parseInt(matchRule[5]);se = parseInt(matchRule[6]);break;default:let doc = this._parser.includedDocuments[dr].tagName;let line = rw;let code = 19;let message = "{0}Bad date pattern at row {1}: the groups must be 3, 5 or 6".format(doc, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}dateTest = new Date(ye, mo - 1, da);if (dateTest.getFullYear() != ye || dateTest.getMonth() != (mo - 1) || dateTest.getDate() != da) {let doc = this._parser.includedDocuments[dr].tagName;let line = rw;let code = 20;let message = "{0}Value is not a valid date at row {1}".format(doc, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}if (ho > 23 || mi > 60 || se > 60) {let doc = this._parser.includedDocuments[dr].tagName;let line = rw;let code = 21;let message = "{0}Value is not a valid datetime at row {1}".format(doc, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}limb.actualValue = dateTest;}else if (checkNumber) {let numberTest = 0;if ( (/^(number|number\[\.\d*\])$/i).test(tgRule) ) {if ( (/^\d+(\.\d+)?$/).test(vl) ) {numberTest = parseFloat(vl);}else {let doc = this._parser.includedDocuments[dr].tagName;let line = rw;let code = 22;let message = "{0}Value is not a valid number at row {1}".format(doc, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}else if ( (/^number\[,\d*\]$/i).test(tgRule) ) {if ( (/^\d+(,\d+)?$/).test(vl) ) {numberTest = parseFloat(vl.replace(",", "."));}else {let doc = this._parser.includedDocuments[dr].tagName;let line = rw;let code = 23;let message = "{0}Value is not a valid number at row {1}".format(doc, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}else {let doc = this._parser.includedDocuments[dr].tagName;let line = rw;let code = 24;let message = "{0}Unmanaged tag [ {1} ] at row {2}".format(doc, tgRule, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}limb.actualValue = numberTest;}}}}}}}}}clearFields () {this._collFields.clear();}ruleIndexing () {for (let k of this._collItem) {var rule = k[1];for (let c of rule.clauses) {var name = c.name.toLowerCase();var rules;if (this._collIndex.has(name)) {rules = this._collIndex.get(name);}else {rules = [];this._collIndex.set(name, rules);}rules.push(rule);}}}syntaxCheck() {if (this.hasSyntaxStructure || this.hasSyntaxRules) {this.ruleIndexing();this.structureInfo = this._parser.structureInfo;this.stackInfos.reset();this.stackInfos.push(this.structureInfo);this._recursiveCheck(this._parser.compound, this.structureInfo, 0, 0);this.engineJS = null;if (this.functProgr > 0) {this._parser.compound.isDynamic = true;this.scriptJS.push("var SELF=false;");this.scriptJS.push("\n");this.scriptJS.push("var BRANCH={};");this.scriptJS.push("\n");this.scriptJS.push("var PATH=[];");this.scriptJS.push("\n");this.scriptJS.push("var HOO=");var jsonHoo = new HoomanExport2JSON(this._parser.compound, false);this.scriptJS.push(jsonHoo.export());this.scriptJS.push(";");this.scriptJS.push("\n");this.scriptJS.push("var TABULAR={};");this.scriptJS.push("\n");if (this._parser.compound.pathExists("hooman/syntax/structure/_tabular")) {let valLimb = this._parser.compound.getLimb("hooman").getLimb("syntax").getLimb("structure").getLimb("_tabular");let _tabular = {};if (valLimb.valueType == HoomanStatics.typeComplex) {let valLimbs = valLimb.complexValue;for (let v of valLimbs) {if (v.valueType == HoomanStatics.typeComplex) {let valSing = v.complexValue;let h = [];for (let z of valSing) {if (z.valueType == HoomanStatics.typeSimple) {h.push(z.simpleValue);}}_tabular[v.name.toLowerCase()] = "|" + h.join("|") + "|";}}}for (let i in _tabular) {this.scriptJS.push("TABULAR['" + i + "']='" + _tabular[i] + "'");this.scriptJS.push("\n");}}let sourceJS = this.scriptJS.join("");this.engineJS = new HoomanEngineJS(sourceJS);this.structureInfo = this._parser.structureInfo;this.stackInfos.reset();this.stackInfos.push(this.structureInfo);this._recursiveCheck(this._parser.compound, this.structureInfo, 1, 0);}}}_recursiveCheck(limb, info, checkType, level) {if (this.hasSyntaxStructure &&checkType == 0 &&info.hasMandatory &&!this._parser.compound.isSyntactic) {for (let f of info.infos) {if (f.isMandatory) {if (!limb.complexValue.exists(f.name)) {let doc = this._parser.includedDocuments[limb.docRef].tagName;let line = limb.row;let code = 25;let message = "{0}Variable [ {1} ] is mandatory below the row {2}".format(doc, f.name, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}}}if (this.hasSyntaxRules) {this.clearFields();}for (let l of limb.complexValue) {if (level > 0 || l.name.toLowerCase() != "hooman") {if (l.valueType == HoomanStatics.typeSimple) {if (this.hasSyntaxRules) {this.addField(l.name.toLowerCase(), l);}}}}if (this.hasSyntaxRules) {this.checkRules(checkType);}for (let l of limb.complexValue) {if (level > 0 || l.name.toLowerCase() != "hooman") {if (l.valueType == HoomanStatics.typeComplex) {if (this.hasSyntaxStructure) {let infoAux = null;if (this.stackInfos.top.hasWildcard) {infoAux = this.stackInfos.top.infos.first;}else {infoAux = this.stackInfos.top.infos.getInfo(l.name);}this.stackInfos.push(infoAux);this._recursiveCheck(l, this.stackInfos.top, checkType, level + 1);this.stackInfos.pop();}else {this._recursiveCheck(l, null, checkType, level + 1);}}}}}assignLimb (limb, formula) {this.engineJS.execute("BRANCH=HOO");this.engineJS.execute("PATH=[]");var maxPath = -1;var p = [];var l = limb;while (l.parent != null) {let name = l.parent.name.toLowerCase();if (/^\d/.test(name)) {name = "i" + name;}maxPath++;p[maxPath] = name;l = l.parent;}for (let i = maxPath - 1; i >= 0; i--) {this.engineJS.execute("BRANCH=BRANCH['" + p[i] + "']");this.engineJS.execute("PATH.push('" + p[i] + "')");}this.engineJS.execute("SELF=BRANCH['" + limb.name.toLowerCase() + "']");let result = this.engineJS.invoke(formula);let sResult;if (result instanceof Date) {sResult =  ("0" + result.getDate()).slice(-2) + "-" +("0"+(result.getMonth()+1)).slice(-2) + "-" +result.getFullYear() + "T" +("0" + result.getHours()).slice(-2) + ":" +("0" + result.getMinutes()).slice(-2) + ":" +("0" + result.getSecond()).slice(-2) .replace("T00:00:00", "");}else {sResult = result.toString();}limb.simpleValue = sResult;}[Symbol.iterator] = function * () {for (let pair of this._collItem) {yield pair[1];}}}class HoomanService {constructor(embodiment) {this.embodiment = embodiment;}parseFile (coords) {var service = this;let prom = new Promise(function(resolve, reject) {try {service.embodiment.getContents(coords) .then( data => {let s = new HoomanStream(data);let ps = new HoomanParser(service.embodiment);ps.resolve = resolve;ps.reject = reject;ps.startProcess("", s);}) .catch( err => {reject({message: err.message, document: "", line: 0, code: 55});});}catch (ex) {reject({message: ex.message, document: "", line: 0, code: 27});}});return prom;}parse(hooDocument) {var service = this;let prom = new Promise(function(resolve, reject) {try {let s = new HoomanStream(hooDocument);let ps = new HoomanParser(service.embodiment);ps.resolve = resolve;ps.reject = reject;ps.startProcess("", s);}catch (ex) {reject({message: ex.message, document: "", line: 0, code: 28});}});return prom;}exportStructureJSON(compound) {let p = compound.getLimb("hooman").getLimb("syntax").getLimb("structure");let expJSON = new HoomanExportStructure2JSON(p);return expJSON.export();}}class HoomanStackDocuments {constructor(parser) {this.parser = parser;this.stack = [];this.topIndex = -1;this.top = null;this.docRef = 0;}push (elem) {this.topIndex++;this.stack[this.topIndex] = elem;this.top = elem;this.docRef++;this.parser.includedDocuments[this.docRef] = new HoomanDocumentInfo(elem.name);elem.docRef = this.docRef;}pop () {this.stack.pop();this.topIndex--;this.top = this.stack[this.topIndex];}reset () {this.stack = [];this.topIndex = -1;this.top = null;this.docRef = 0;this.parser.includedDocuments = [];}}class HoomanStackInfos {_parser;_backup;_stack;_topIndex;_topIndexBackup;_top;_baseRecursionIndex;_baseRecursionName;_recursionCount;_recursionIsActive;constructor (parser) {this._parser = parser;this._stack = [];this._backup = [];this._topIndex = -1;this._topIndexBackup = -1;this._top = null;this._baseRecursionIndex = 0;this._baseRecursionName = "";this._recursionCount = 0;this._recursionIsActive = false;}push (elem) {if (elem.isRecursive && this._recursionCount == 0) {this._topIndex++;this._stack[this._topIndex] = elem;this._top = elem;this._baseRecursionIndex = this._topIndex;this._recursionCount = 1;this._baseRecursionName = elem.name.toLowerCase();}else if (elem.name.toLowerCase() == this._baseRecursionName) {this._recursionCount++;do {this._stack.pop();this._topIndex--;} while (this._topIndex != this._baseRecursionIndex);let x = this._stack[ this._baseRecursionIndex ];elem.hasDefault = x.hasDefault;elem.hasWildcard = x.hasWildcard;elem.isRecursive = x.isRecursive;this._top = this._stack[ this._topIndex ];}else {this._topIndex++;this._stack[ this._topIndex ] = elem;this._top = elem;if (this._recursionCount == 1) {this._topIndexBackup++;this._backup[ this._topIndexBackup ] = elem;}}}pop () {if (this._top.isRecursive) {this._recursionCount--;if (this._recursionCount < 0) {this._stack.pop();this._topIndex--;this._top = this._stack[ this._topIndex ];this._recursionCount = 0;this._recursionIsActive = false;}else if (this._recursionCount == 0) {this._stack.pop();this._topIndex--;this._top = this._stack[ this._topIndex ];while (this._topIndexBackup != -1) {this._backup.pop();this._topIndexBackup--;}this._baseRecursionIndex = -1;this._baseRecursionName = "";this._recursionCount = 0;this._recursionIsActive = false;}else {for (let i = 0; i <= this._topIndexBackup; i++) {this._topIndex++;this._stack[ this._topIndex ] = this._backup[i];this._top = this._backup[i];}}}else if (this._top.name.toLowerCase() == this._baseRecursionName) {throw new Error("Internal error");}else {this._stack.pop();this._topIndex--;this._top = this._stack[ this._topIndex ];if (this._recursionCount == 1) {this._backup.pop();this._topIndexBackup--;}}}reset () {this._stack = [];this._backup = [];this._topIndex = -1;this._topIndexBackup = -1;this._top = null;this._baseRecursionIndex = -1;this._baseRecursionName = "";this._recursionCount = 0;this._recursionIsActive = false;}get topIndex () {if (this._recursionCount == 0) {return this._topIndex;}else {return (this._recursionCount - 1) * (this._backup.length + 1) + this._topIndex;}}get top () {return this._top;}get topParent () {return this._stack[ this._topIndex - 1 ];}valueManagement (value) {if (value == "*") {if (this.topParent.infos.count() > 1) {let doc = this._parser.document.namex;let line = this._parser.document.row;let code = 29;let message = "{0}A wildcard variable cannot have siblings at row {1}".format(doc, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}this._top.isWildcard = true;this.topParent.hasWildcard = true;}else if (value == "...") {if (this._recursionIsActive) {let doc = this._parser.document.namex;let line = this._parser.document.row;let code = 30;let message = "{0}Multiple recursions cannot be nested at the same time at row {1}".format(doc, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}this._recursionIsActive = true;this._top.isRecursive = true;}else if (value == "!") {this._top.isMandatory = true;this.topParent.hasMandatory = true;}else if (value != "") {this._top.isDefault = true;this._top.defaultValue = value;this.topParent.hasDefault = true;}}}class HoomanStackLimbs {_stack;_topIndex;_top;constructor () {this._stack = [];this._topIndex = -1;this._top = null;}push (elem) {this._topIndex++;this._stack[this._topIndex] = elem;this._top = elem;}pop () {this._stack.pop();this._topIndex--;this._top = this._stack[ this._topIndex ];}reset () {this._stack = [];this._topIndex = -1;this._top = null;}get topIndex () {return this._topIndex;}get top () {return this._top;}}class HoomanStackStreams {_stack;_topIndex;_top;constructor () {this._stack = [];this._topIndex = -1;this._top = null;}push (elem) {this._topIndex++;this._stack[this._topIndex] = elem;this._top = elem;}pop () {this._stack.pop();this._topIndex--;this._top = this._stack[ this._topIndex ];}reset () {this._stack = [];this._topIndex = -1;this._top = null;}get topIndex () {return this._topIndex;}get top () {return this._top;}}class HoomanState {parser;stateAssignment;stateBOM;stateFinal;stateGuillemotBegin;stateGuillemotBody;stateGuillemotEnd;stateGuillemotIndentation;stateIncludeSub;stateIncludeText;stateIndentation;stateInitial;stateLessThan;stateRemark;stateValue;stateVariable;statePlus;stateThen;constructor(parser) {this.parser = parser;}initialize(){}get buffer () {return "";}get name () {return "";}complete () {}finalCheck () {}nextSymbol (b) {}reset () {}}class HoomanStateAssignment extends HoomanState {constructor(parser) {super(parser);}get name () {return "Assignment";}nextSymbol (b) {if (b == "\r" || b == "\n") {this.parser.changeState(this.parser.stateIndentation, b);}else if (b == " " || b == "\t") {}else{this.parser.changeState(this.parser.stateValue, b);}}}class HoomanStateBOM extends HoomanState {constructor(parser) {super(parser);}}class HoomanStateFinal extends HoomanState {constructor(parser) {super(parser);}}class HoomanStateGuillemotBegin extends HoomanState {_buffer;constructor(parser) {super(parser);}get buffer () {return this._buffer.join("").trim();}get name () {return "GuillemotBegin";}complete () {this.parser.stackLimbs.top.tag = this.buffer;}nextSymbol (b) {if (b == "\r" || b == "\n") {this.parser.document.guillemotSession = true;this.parser.document.guillemotSkipNewLine = true;this.parser.document.guillemotBuffer = [];this.parser.changeState(this.parser.stateGuillemotIndentation, b);}else {this._buffer.push(b);}}reset () {this._buffer = [];}finalCheck () {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 31;let message = "{0}The guillemots have not a closure at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}class HoomanStateGuillemotBody extends HoomanState {_buffer;constructor(parser) {super(parser);}get buffer () {return this._buffer.join("");}get name () {return "GuillemotBody";}complete () {this.parser.document.guillemotBuffer.push(this.buffer);}nextSymbol (b) {if (b == "\r" || b == "\n") {this.parser.changeState(this.parser.stateGuillemotIndentation, b);}else {this._buffer.push(b);}}reset () {this._buffer = [];}finalCheck () {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 32;let message = "{0}The guillemots have not a closure at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}class HoomanStateGuillemotEnd extends HoomanState {_buffer;constructor(parser) {super(parser);}get buffer () {return this._buffer.join("");}get name () {return "GuillemotEnd";}complete () {var value = this.parser.document.guillemotBuffer.join("");var currDocRef = this.parser.document.docRef;var objTop = this.parser.stackLimbs.top;if (objTop.owner != currDocRef) {if (this.parser.includedDocuments[objTop.owner].locked) {let doc = this.parser.includedDocuments[currDocRef].tagName;let line = objTop.row;let code = 33;let message = "{0}Access violation at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}else {objTop.simpleValue = value;}}else {objTop.simpleValue = value;}this.parser.currentPhase.valueManagement(value);}nextSymbol (b) {if (b == ">") {this._buffer.push(b);}else if (b == "\r" || b == "\n") {if (this._buffer.join("") == ">>") {this.parser.document.guillemotSession = false;this.parser.changeState(this.parser.stateIndentation, b);}else {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 34;let message = "{0}Syntax error at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}else if (b == " " || b == "\t") {}else {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 35;let message = "{0}Unexpected character at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}reset () {this._buffer = [];}}class HoomanStateGuillemotIndentation extends HoomanState {_indentation;_spaces;_spacesForTab;_docIndentation;constructor(parser) {super(parser);}get name () {return "GuillemotIndentation";}nextSymbol (b) {if (b == "\r" || b == "\n") {this._spaces = 0;this._indentation = this.parser.document.offset;}else if (b == " ") {this._spaces++;if (this._spaces == this._spacesForTab) {this._spaces = 0;this._indentation++;}}else if (b == "\t") {this._spaces = 0;this._indentation++;}else if (b == "*") {this.parser.changeState(this.parser.stateRemark, b);}else if (b == "<") {if (this._indentation == this._docIndentation) {this.parser.changeState(this.parser.stateLessThan, b);}else {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 36;let message = "{0}Wrong indentation at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}else if (b == ">") {if (this._indentation == this._docIndentation) {this.parser.changeState(this.parser.stateGuillemotEnd, b);}else {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 37;let message = "{0}Wrong indentation at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}else {let doc = this.parser.document.namex;let line = this.parser.document.row - 1;let code = 38;let message = "{0}The guillemots have not a closure at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}if (this._indentation > this._docIndentation) {if (this.parser.document.guillemotSkipNewLine) {this.parser.document.guillemotSkipNewLine = false;}else {this.parser.document.guillemotBuffer.push("\n");}this.parser.changeState(this.parser.stateGuillemotBody, null);}}reset () {this._spaces = 0;this._indentation = this.parser.document.offset;this._spacesForTab = this.parser.document.spacesForTab;this._docIndentation = this.parser.document.indentation;}finalCheck () {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 39;let message = "{0}The guillemots have not a closure at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}class HoomanStateIncludeSub extends HoomanState {_buffer;constructor(parser) {super(parser);}get buffer () {return this._buffer.join("").trim();}get name () {return "IncludeSub";}complete () {var name = this.buffer;var parser = this.parser;this.parser.embodiment.getContents(name) .then( data => {try {let streamIn = new HoomanStream(data);parser.currentState = parser.stateInitial;parser.stackDocuments.push(new HoomanDocument(parser, name, parser.stackDocuments.top.indentation));parser.stackStreams.push(streamIn);parser.streamProcess(streamIn);}catch (ex) {let doc = parser.document.namex;let line = parser.document.row;let code = 56;let message = ex.message;this.parser.reject({message: message, document: doc, line: line, code: code});}}) .catch( err => {let doc = parser.document.namex;let line = parser.document.row;let code = 57;let message = err.message;this.parser.reject({message: message, document: doc, line: line, code: code});});}nextSymbol (b) {switch (b) {case "\r":case "\n":this.parser.changeState(this.parser.stateIndentation, b);return true;default:this._buffer.push(b);}}reset () {this._buffer = [];}}class HoomanStateIncludeText extends HoomanState {_buffer;constructor(parser) {super(parser);}get buffer () {return this._buffer.join("");}get name () {return "IncludeText";}complete () {var name = this.buffer;var parser = this.parser;parser.embodiment.getContents(name) .then( data => {try {let streamIn = new HoomanStream(data);var notInitialized = true;var newLineCharacter = "\n";var newLineExcluded = "\r";var buffer = [];buffer.push("\n");do {let currChar = streamIn.getNext();if (currChar == "") {break;}if (notInitialized) {if (currChar == "\n") {newLineCharacter = "\n";newLineExcluded = "\r";notInitialized = false;}else if (currChar == "\r") {newLineCharacter = "\r";newLineExcluded = "\n";notInitialized = false;}}if (currChar != newLineExcluded) {if (currChar == "\r") {currChar = "\n"}buffer.push(currChar);}} while (true);parser.document.guillemotBuffer.push(buffer.join(""));parser.currentState = parser.stateGuillemotIndentation;parser.streamProcess (parser.stackStreams.top);}catch (ex) {throw new Error(ex.message);}}) .catch( err => {throw new Error(err);});}nextSymbol (b) {switch (b) {case "\r":case "\n":this.parser.changeState(this.parser.stateGuillemotIndentation, b);return true;default:this._buffer.push(b);}}reset () {this._buffer = [];}}class HoomanStateIndentation extends HoomanState {_indentation;_spaces;_spacesForTab;constructor(parser) {super(parser);}initialize () {this.stateVariable = this.parser.stateVariable;this.stateRemark = this.parser.stateRemark;this.stateLessThan = this.parser.stateLessThan;this.statePlus = this.parser.statePlus;this.stateThen = this.parser.stateThen;}get name () {return "Indentation";}nextSymbol (b) {if ( ("A" <= b && b <= "Z" ) || ("a" <= b && b <= "z" ) || b == "_" || ("0" <= b && b <= "9" )) {this.parser.document.indentation = this._indentation;this.parser.changeState(this.stateVariable, b);}else if (b == "*") {this.parser.changeState(this.stateRemark, b);}else if (b == "<") {this.parser.document.indentation = this._indentation;this.parser.changeState(this.stateLessThan, b);}else if (b == "+") {this.parser.document.indentation = this._indentation;this.parser.changeState(this.statePlus, null);}else if (b == "=") {this.parser.document.indentation = this._indentation;this.parser.changeState(this.stateThen, b);}else if (b == " ") {this._spaces++;if (this._spaces == this._spacesForTab) {this._spaces = 0;this._indentation++;}}else if (b == "\r" || b == "\n") {this._spaces = 0;this._indentation = 0;}else if (b == "\t") {this._spaces = 0;this._indentation++;}else{let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 40;let message = "{0}Syntax error at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}reset () {this._indentation = 0;this._spaces = 0;this._spacesForTab = this.parser.document.spacesForTab;}}class HoomanStateInitial extends HoomanState {constructor(parser) {super(parser);}get name () {return "Initial";}nextSymbol (b) {if ( ("A" <= b && b <= "Z" ) || ("a" <= b && b <= "z" ) || b == "_" || ("0" <= b && b <= "9" )) {this.parser.changeState(this.parser.stateVariable, b);}else if (b == "\r" || b == "\n") {this.parser.changeState(this.parser.stateIndentation, b);}else if (b == " " || b == "\t") {this.parser.changeState(this.parser.stateIndentation, b);}else if (b == "\x00" || b == "\xEF" || b == "\xFE" || b == "\xFF" || b == "\xBB") {this.parser.changeState(this.parser.stateBOM, b);}else if (b == "*") {this.parser.changeState(this.parser.stateRemark, b);}else if (b == "+") {this.parser.changeState(this.parser.statePlus, null);}else if (b == "<") {this.parser.changeState(this.parser.stateLessThan, b);}else{let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 41;let message = "{0}Unexpected character at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}}class HoomanStateLessThan extends HoomanState {_buffer;constructor(parser) {super(parser);}get name () {return "LessThan";}nextSymbol (b) {let prefix;let message;let doc;let line;let code;switch (b) {case "<":case "-":case " ":case "\t":break;case "\r":case "\n":doc = this.parser.document.namex;line = this.parser.document.row;code = 42;message = "{0}Syntax error at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);default:doc = this.parser.document.namex;line = this.parser.document.row;code = 43;message = "{0}Unexpected character at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}this._buffer.push(b);switch (this._buffer.length) {case 1:break;case 2:if (this._buffer.join("") == "<<") {if (this.parser.document.indentation == this.parser.stackLimbs.top.level + 1) {this.parser.changeState(this.parser.stateGuillemotBegin, null);}else {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 44;let message = "{0}Wrong indentation at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}break;case 3:break;case 4:prefix =this._buffer.join("");if (prefix == "<-- " || prefix == "<--\t") {if (this.parser.document.guillemotSession) {this.parser.changeState(this.parser.stateIncludeText, null);}else {this.parser.changeState(this.parser.stateIncludeSub, null);}}break;default:let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 45;let message = "{0}Syntax error at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}reset () {this._buffer = [];}finalCheck () {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 46;let message = "{0}Syntax error at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}class HoomanStatePlus extends HoomanState {_buffer;constructor(parser) {super(parser);}initialize () {this.stateIndentation = this.parser.stateIndentation;this.stateAssignment = this.parser.stateAssignment;}get buffer () {return this._buffer.join("");}get name () {return "Plus";}complete () {this.parser.stackManagement("+");}nextSymbol (b) {switch (b) {case "\r":case "\n":this.parser.changeState(this.stateIndentation, b);break;case " ":case "\t":this.parser.changeState(this.stateAssignment, b);break;default:let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 47;let message = "{0}Unexpected character at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}reset () {this._buffer = [];}}class HoomanStateRemark extends HoomanState {_buffer;_flagPrefix;constructor(parser) {super(parser);}get buffer () {return this._buffer.join("");}get name () {return "Remark";}nextSymbol (b) {if (this._flagPrefix) {if (b == "\r" || b == "\n") {if (this.parser.document.guillemotSession) {this.parser.document.guillemotSkipNewLine = true;this.parser.changeState(this.parser.stateGuillemotIndentation, b);}else {this.parser.changeState(this.parser.stateIndentation, b);}}}else {this._buffer.push(b);var prefix = this.buffer;if (prefix == "***") {this._flagPrefix = true;}else if (!("***".startsWith(prefix))) {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 48;let message = "{0}Syntax error at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}}reset () {this._buffer = [];this._flagPrefix = false;}}class HoomanStateThen extends HoomanState {_buffer;_separator;constructor(parser) {super(parser);}get buffer () {return this._buffer.join("");}get name () {return "Then";}complete () {this.parser.thenOccurred = true;}nextSymbol (b) {switch (b) {case "\r":case "\n":if (this._buffer.join("") != "==>") {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 49;let message = "{0}Syntax error at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}this.parser.changeState(this.parser.stateIndentation, b);break;case " ":case "\t":this._separator = true;break;default:if (this._separator) {let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 50;let message = "{0}Syntax error at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}this._buffer.push(b);}}reset () {this._buffer = [];this._separator = false;}}class HoomanStateValue extends HoomanState {_buffer;constructor(parser) {super(parser);}initialize () {this.stateIndentation = this.parser.StateIndentation;}get buffer () {return this._buffer.join("").trim();}get name () {return "Value";}complete () {var value = this.buffer;var currDocRef = this.parser.document.docRef;var objTop = this.parser.stackLimbs.top;if (objTop.valueType == HoomanStatics.typeComplex) {if (value == "@") {this._checkLocked(objTop.complexValue, currDocRef, this.parser.document.row);objTop.prune();}}else if (objTop.owner != currDocRef) {if (this.parser.includedDocuments[objTop.owner].locked) {let doc = this.parser.includedDocuments[currDocRef].tagName;let line = objTop.row;let code = 51;let message = "{0}Access violation at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}else {objTop.simpleValue = value;}}else {objTop.simpleValue = value;}this.parser.currentPhase.valueManagement(value);}_checkLocked (limbs, currDocRef, row) {for (let l of limbs) {if (l.valueType == HoomanStatics.typeComplex) {this._checkLocked(l.complexValue, currDocRef, row);}else if (l.owner != currDocRef) {if (this.parser.includedDocuments[l.owner].locked) {let doc = this.parser.includedDocuments[currDocRef].tagName;let line = row;let code = 52;let message = "{0}Access violation at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}}}nextSymbol (b) {if (b == "\r" || b == "\n") {this.parser.changeState(this.parser.stateIndentation, b);}else{this._buffer.push(b);}}reset () {this._buffer = [];}}class HoomanStateVariable extends HoomanState {_buffer;constructor(parser) {super(parser);}initialize () {this.stateIndentation = this.parser.StateIndentation;this.stateAssignment = this.parser.stateAssignment;}get buffer () {return this._buffer.join("");}get name () {return "Variable";}complete () {this.parser.stackManagement(this.buffer);}nextSymbol (b) {if ( ("A" <= b && b <= "Z" ) || ("a" <= b && b <= "z" ) || b == "_" || ("0" <= b && b <= "9" )) {this._buffer.push(b);}else if (b == "\r" || b == "\n") {this.parser.changeState(this.parser.stateIndentation, b);}else if (b == " " || b == "\t") {this.parser.changeState(this.parser.stateAssignment, b);}else{let doc = this.parser.document.namex;let line = this.parser.document.row;let code = 53;let message = "{0}Syntax error at row {1}".format(doc, line);this.parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}reset () {this._buffer = [];}}class HoomanStatics {static typeSimple = 0;static typeComplex = 1;static _flagInit = false;static initSystem () {if (!this._flagInit) {this._flagInit = true;String.prototype.format = function() {var a = this;for (let k in arguments) {a = a.replace("{" + k + "}", arguments[k]);}return a;}}}}HoomanStatics.initSystem();class HoomanStream {constructor(bytes) {this.bytes = bytes;this.cursor = -1;}getNext () {this.cursor += 1;if (this.cursor < this.bytes.length) {return this.bytes[this.cursor];}else {return "";}}}class HoomanStructureInfo {_parser;name;isWildcard;hasWildcard;isRecursive;isDefault;defaultValue;hasDefault;isMandatory;hasMandatory;infos;constructor(parser, name) {this._parser = parser;this.name = name;this.isWildcard = false;this.hasWildcard = false;this.isRecursive = false;this.isDefault = false;this.defaultValue = "";this.hasDefault = false;this.isMandatory = false;this.hasMandatory = false;this.infos = new HoomanStructureInfos(parser);}}class HoomanStructureInfos {_parser;_collItem;constructor(parser) {this._parser = parser;this._collItem = new Map();}exists (name) {return this._collItem.has(name);}getInfo (name) {name = name.toLowerCase();if (this._collItem.has(name)) {return this._collItem.get(name.toLowerCase());}else {let doc = this._parser.includedDocuments[ this._parser.document.docRef ].tagName;let line = this._parser.document.row;let code = 54;let message = "{0}Variable [ {1} ] is not allowed at row {2}".format(doc, name, line);this._parser.reject({message: message, document: doc, line: line, code: code});throw new Error(message);}}count () {return this._collItem.size;}add (item) {var name = item.name.toLowerCase();this._collItem.set(name, item);}clear () {this.collItem.clear();}remove (item) {return this._collItem.remove(item.name);}get first() {if (this._collItem.size > 0) {return this._collItem.values().next().value;}else {return null;}}[Symbol.iterator] = function * () {for (let pair of this._collItem) {yield pair[1];}}}class HoomanEmbodimentURL {baseURL;constructor(baseURL = "") {if (baseURL!= "" && !baseURL.endsWith("/")) {baseURL += "/";}this.baseURL = baseURL;}getContents (coords) {if (coords.indexOf("//") == -1 && coords.indexOf(":") == -1) {coords = this.baseURL + coords;}let prom = new Promise(function(resolve, reject) {try {fetch(coords) .then( response => {if (response.ok) {return response.text();}else {let message = "File [ {0} ] not available".format(coords);reject({message: message});return false;}}) .then( data => {if (data !== false) {if (!data.endsWith("\n") && !data.endsWith("\r")) {if (data.indexOf("\r\n")) {data += "\r\n";}else if (data.indexOf("\r")) {data += "\r";}else {data += "\n";}}resolve(data);}}) .catch ( err => {reject({message: err.message});});}catch (ex) {reject({message: ex.message});}});return prom;}}class HoomanExport2HOO {_root;constructor(limb) {this._root = limb;}export () {try {var build = [];this._recursiveWalk(build, this._root, 0);return build.join("");}catch (ex) {throw new Error(ex.message);}}_recursiveWalk(build, limb, level) {for (let l of limb.complexValue) {if (level > 0 || l.name.toLowerCase() != "hooman") {if(level > 0){build.push("\t".repeat(level));}build.push(l.name);if (l.valueType == HoomanStatics.typeSimple) {let oVl = l.actualValue;let sVl;if (oVl.constructor.name == "String") {sVl = oVl;}else if (oVl.constructor.name == "Date") {sVl =  (oVl.getFullYear() + "-" +("0"+(oVl.getMonth()+1)).slice(-2) + "-" +("0" + oVl.getDate()).slice(-2) + "T" +("0" + oVl.getHours()).slice(-2) + ":" +("0" + oVl.getMinutes()).slice(-2) + ":" +("0" + oVl.getSeconds()).slice(-2)) .replace("T00:00:00", "");}else {sVl = oVl.toString();}if(sVl.indexOf("\n") >= 0){let matchRows = sVl.split("\n");build.push("\n");build.push("\t".repeat(level + 1));build.push("<<");build.push(l.tag);build.push("\n");for (let matchRow of matchRows) {build.push("\t".repeat(level + 2));build.push(matchRow);build.push("\n");}build.push("\t".repeat(level + 1));build.push(">>\n");}else{build.push(" ");build.push(sVl);build.push("\n");}}else {build.push("\n");this._recursiveWalk(build, l, level + 1);}}}}}module.exports = {HoomanStatics, HoomanService, HoomanEmbodimentURL, HoomanEmbodimentFile, HoomanExport2JSON, HoomanExportStructure2JSON, HoomanExport2HOO};
